NIO编程的优点:
1.客户端发起连接的过程是异步的,通过多虑复用器Selector注册OP_CONNECT等待后续结果
2.SocketChannel的读写操作都是异步的,如果没有可读写的数据,就不会同步等待,IO通信而是处理其他链路
3.线程模型的优化:jdk的Selector在Linux等主流操作系统上通过epoll实现,它没有连接句柄的限制,意味着一个Selector线程可以处理成千上万的客户端连接,性能不会随着客户端的增加而下降,因此它非常适合做高性能高负载的应用服务器.
jdk1.4:NIO1.0 jdk1.7:NIO2.0(提供了异步文件io操作,同时提供了Unix网络编程事件驱动io对应的AIO)

AIO编程:
NIO2.0提供了异步通道的概念,提供了异步文件通道和异步套接字通道的实现.
异步通信通过两种方式获取操作结果:
1)java.util.concurrent.Future来表示异步操作结果.
2)在执行异步操作的时候传入一个java.nio.channels
CompletionHandler接口的实现类作为操作完成的回调
NIO2.0的异步套接字通道是真正的异步非阻塞io,对应于unix中的事件驱动io(AIO).而不需要通过多路复用器Selector的轮询即可实现异步读写.

异步socketchannel是被动执行的对象,aio不需要像NIO编程那样创建一个独立的io线程来处理读写操作,对于AsynchronoursServerSocketChannel和AsynchronoursSocketChannel而言,他们都由jdk底层的线程池
负责回调并驱动读写操作.

概念澄清:
1.	异步非阻塞io:很多人喜欢将jdk1.4提供的NIO框架成为异步非阻塞i/o,但是,如果严格按照Unix网络编程模型和jdk的实现进行区分,实际上
	只能它只能被成为非阻塞io,不能叫异步非阻塞io.在早期的jdk1.4和1.5update10版本之前,jdk的Selector基于select/poll模型
	实现,它是基于io复用技术的非阻塞io,不是异步io.在jdk1.5update10和linux core2.6以上的版本,sun优化了Selector的实现
	使用了epoll替换了select/poll,上层的api并没有变化.可以认为是jdk NIO的一次性能的优化,但是它仍旧没有改变i/o的模型.
	由于jdk1.7提供的NIO2.0新增了异步套接字通道,它是真正的异步i/o,在异步io操作的时候可以传递信号变量,当操作完成之后会回调相关的方法
	,异步io也被称为AIO.
	NIO类库支持非阻塞读和写操作,相比于之前的同步阻塞读和写,它是异步的,因此很多人习惯于称NIO为异步非阻塞io,包括很多介绍nio编程的数据页沿用这个说法.
2.	多路复用Selector
	几乎所有的中文技术书籍都将Selector翻译为选择器,这样体现不出来Selector的功能和特点.java NIO的实现关键技术是多路复用io技术,多路复用的核心就是通过Selector来轮询注册在其上的Channel,当发现某个或者多个Channel出于就绪状态
	后,会从阻塞状态返回就绪的Channel的选择键的集合,进行io操作.所以在netty权威指南中将Selector翻译为多路复用器.与其他的技术书籍所说的选择器是一个东西.
3.伪异步io
	伪异步io的概念完全来源于实践.在jdk NIO编程没有流行之前,为了解决tomcat通信线程的同步io导致业务线程被挂住的问题:在通信线程和业务线程之间做了一个缓冲区,这个缓冲区用于隔离io线程和业务线程间的直接访问,这样业务线程就不会被io线程阻塞.
	而对于后端的业务侧来说,将消息或者Task放到线程池后就反悔了,它不再直接访问io线程或者进行io读写,这样也就不会被同步阻塞.类似的设计还包括前段启动一组线程,将接受的客户端封装成Task,放到后端的线程池中执行,用于解决一连接一线程的问题.像这样通过线程池做缓冲
	区的做法,本书称之为伪异步io.而官方并没有这个说法!