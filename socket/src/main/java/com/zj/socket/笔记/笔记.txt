Netty学习笔记:

NIO编程的优点:
1.客户端发起连接的过程是异步的,通过多虑复用器Selector注册OP_CONNECT等待后续结果
2.SocketChannel的读写操作都是异步的,如果没有可读写的数据,就不会同步等待,IO通信而是处理其他链路
3.线程模型的优化:jdk的Selector在Linux等主流操作系统上通过epoll实现,它没有连接句柄的限制,意味着一个Selector线程可以处理成千上万的客户端连接,性能不会随着客户端的增加而下降,因此它非常适合做高性能高负载的应用服务器.
jdk1.4:NIO1.0 jdk1.7:NIO2.0(提供了异步文件io操作,同时提供了Unix网络编程事件驱动io对应的AIO)

AIO编程:
NIO2.0提供了异步通道的概念,提供了异步文件通道和异步套接字通道的实现.
异步通信通过两种方式获取操作结果:
1)java.util.concurrent.Future来表示异步操作结果.
2)在执行异步操作的时候传入一个java.nio.channels
CompletionHandler接口的实现类作为操作完成的回调
NIO2.0的异步套接字通道是真正的异步非阻塞io,对应于unix中的事件驱动io(AIO).而不需要通过多路复用器Selector的轮询即可实现异步读写.

异步socketchannel是被动执行的对象,aio不需要像NIO编程那样创建一个独立的io线程来处理读写操作,对于AsynchronoursServerSocketChannel和AsynchronoursSocketChannel而言,他们都由jdk底层的线程池
负责回调并驱动读写操作.

概念澄清:
1.	异步非阻塞io:很多人喜欢将jdk1.4提供的NIO框架成为异步非阻塞i/o,但是,如果严格按照Unix网络编程模型和jdk的实现进行区分,实际上
	只能它只能被成为非阻塞io,不能叫异步非阻塞io.在早期的jdk1.4和1.5update10版本之前,jdk的Selector基于select/poll模型
	实现,它是基于io复用技术的非阻塞io,不是异步io.在jdk1.5update10和linux core2.6以上的版本,sun优化了Selector的实现
	使用了epoll替换了select/poll,上层的api并没有变化.可以认为是jdk NIO的一次性能的优化,但是它仍旧没有改变i/o的模型.
	由于jdk1.7提供的NIO2.0新增了异步套接字通道,它是真正的异步i/o,在异步io操作的时候可以传递信号变量,当操作完成之后会回调相关的方法
	,异步io也被称为AIO.
	NIO类库支持非阻塞读和写操作,相比于之前的同步阻塞读和写,它是异步的,因此很多人习惯于称NIO为异步非阻塞io,包括很多介绍nio编程的数据页沿用这个说法.
2.	多路复用Selector
	几乎所有的中文技术书籍都将Selector翻译为选择器,这样体现不出来Selector的功能和特点.java NIO的实现关键技术是多路复用io技术,多路复用的核心就是通过Selector来轮询注册在其上的Channel,当发现某个或者多个Channel出于就绪状态
	后,会从阻塞状态返回就绪的Channel的选择键的集合,进行io操作.所以在netty权威指南中将Selector翻译为多路复用器.与其他的技术书籍所说的选择器是一个东西.
3.伪异步io
	伪异步io的概念完全来源于实践.在jdk NIO编程没有流行之前,为了解决tomcat通信线程的同步io导致业务线程被挂住的问题:在通信线程和业务线程之间做了一个缓冲区,这个缓冲区用于隔离io线程和业务线程间的直接访问,这样业务线程就不会被io线程阻塞.
	而对于后端的业务侧来说,将消息或者Task放到线程池后就反悔了,它不再直接访问io线程或者进行io读写,这样也就不会被同步阻塞.类似的设计还包括前段启动一组线程,将接受的客户端封装成Task,放到后端的线程池中执行,用于解决一连接一线程的问题.像这样通过线程池做缓冲
	区的做法,本书称之为伪异步io.而官方并没有这个说法!
	
TCP粘包问题的解解决策略:
由于底层的TCP无法理解上层的业务数据,所以在底层是无法保证数据包不被拆分和重组的.这个问题只能通过上层的应用协议栈设计来解决,可以归纳如下:
1.消息定长2.在包尾增加换行符进行分割,例如FTP协议3.将消息分为消息头和消息体,消息头中包含表示消息总长度的字段.4.更复杂的应用层协议

Netty通过LineBasedFrameDecoder和StringDecoder来解决半包粘包问题.
原理分析:
LineBasedFrameDecoder的工作原理是它一次遍历ByteBuf中的可读字节,判断看是否有"\n"或者"\r\n",如果有就以此位置为结束位置,从可读索引到结束位置区间的字节就组成了一行.它是以换行符为结束标志的解码器,支持携带结束符或者不携带
结束符两种解码方式,同时支持配置单行的最大长度.如果连续读取到的最大长度后仍然没有发现换行符,就会抛出异常,同时忽略掉执勤啊独到的异常码流.
StringDecoder的功能非常简单,就是将接收到的对象转换成字符串,然后继续调用后面的Handler.LineBasedFrameDecoder+StringDecoder组合就是按行切换的文本解码器,它被设计用来支持TCP的粘包和拆包.

CHP5分隔符和定长解码器的应用
	TCP以流的方式进行数据传输,的上层应用协议为了对消息进行区分,采用以下四种方式:
		1.消息长度固定,累计读取到消息长度为LEN的报文后就认为读到一个完整的消息;将计数器置位,重新开始读取下一个消息.
		2.将回车换行符作为消息结束符,例如FTP协议,这种方式在文本协议中应用比较广泛.
		3.将特殊的分隔符作为消息的结束标志,例如回车符.
		4.通过在消息头中定义消息长度字段来定义消息的总长度.
	Netty对以上4种应用做了统一的抽象,提供四种解码器来解决对应的问题.
	本章学习:DelimiterBasedFrameDecoder和FixedLengthFrameDecoder解码器,前者可以自动完成分割符做标志的消息解码,后者可以完成定长消息的解码.他们都能解决TCP粘包/拆包导致的读半包的问题.
	利用FixedLengthFrameDecoder进行解码,无论一次收到多少数据报,都会按照构造函数中设置的长度进行解码,如果是半包消息,FixedLengthFrameDecoder会缓存半包消息并等待下个包到达后进行拼包,知道读取到一个完整的数据包.
CHP6编解码技术:
	基于java提供的对象输入输出流ObjectInputStream和ObjectOutputStream,可以直接把java中的对象作为可存储的字节写入文件,也可以传输到网络上.对于开发人员来说,基于这种方式可以避免碰触底层数组,从而提升效率.
	java序列化的目的主要有两个:1. 网络传输2. 对象持久化
	当进行跨进程服务调用时,需要把被传输的java对象编码为字节数组或者ByteBuffer对象,反之亦然.这被成为java对象的编解码技术.
	java序列化的缺点:1.无法跨语言(无法和异构语言进行交互,java语言内部的私有协议,其他语言并不支持)2.序列化后的码流太大3. 序列化性能太低.
	评判一个编解码框架德优劣时,往往会考虑一下几个因素:
		1. 是否支持跨语言,支持的语言种类是否丰富.
		2. 编码后的码流的大小.
		3. 编解码的性能.
		4. 类库是否小巧,API是否方便.
		5. 使用者需要手工开发的工作量和难度.
		所以,java序列化的码流偏大也一直被业界所诟病,导致他的应用范围收到了很大的限制.
	业界主流的编解码框架:
	1.Google protobuf:全称google protocol buffers,它将数据结构以.proto文件进行描述,通过代码生成工具可以生成对应数据结构的pojo对象和Protobuf相关的方法和属性.
		特点:
			1.结构化数据存储格式(xml,json等)
			2.高效的编解码性能
			3.语言无关,平台无关,扩展性好
			4.官方支持java,c++和Python三种语言
		protobuf采用二进制编码,在空间和性能上相比于xml具有更大的优势.另外有一个吸引人的地方就是他的数据描述文件合代码生成机制,利用数据描述文件对数据结构进行说明的优点如下:
			1.文本化的数据结构描述语言,可以实现语言和平台无关,特别适合异构系统间的集成.
			2.通过标识字段的顺序,可以实现协议的向前兼容.
			3.自动代码生成,不需要手工编写同样的数据结构的c++和java版本.
			4.方便后续管理和维护.相比于代码,结构化的文档更容易管理和维护.
	2.Facebook的Thrift介绍:thrift起源于facebook,2007年将Thrift作为一个开源项目提交给了Apache基金会.对于当时的Facebook来说,创造Thrift是为了解决各系统间大数据量的传输通信以及系统之家你语言环境不同需要跨平台的特性.Thrift支持c++,c#,Cocoa,Erlang,Haskell,java,Ocami,Perl,PHP,Python,ruby和SmallTalk.
		在多种不同的语言之间,Thrift支持数据的序列化和多种类型的rpc服务.Thrift适用于静态数据的交换,需要先确定好它的数据结构,当数据结构发生变化时,必须重新编辑IDL文件,生成代码和编译,这一点跟其他IDL工具相比可以视为是Thrift的弱项.Thrift适用于搭建大型数据交换及存储的通用工具,对于大型系统中的内部数据传输,相对于JSON和xml在性能和传输大小上都有明显的优势:
		Thrift主要有5部分组成:
			1.语言系统以及IDL编辑器:负责由用户给定的IDL文件生成相应语言的接口代码.
			2.TProtocol:RPC的协议层,可以选择多种不同的对象序列化方式,如JSON和Binary;
			3.TTransport:RPC的传输层,同样可以选择不同的传输层实现,如socket,NIO,MemoryBuffer等.
			4.TProcessor:作为协议层和用户提供的服务实现之间的纽带,负责调用服务实现的接口;
			5.TServer:聚合TProtocol,TTransport和TProcessor等对象.
	我们重点关注的是编解码框架,与之对应的就是TProtocol.由于Thrift的RPC服务调用和编解码框架绑定在一起,所以,通常我们使用Thrift的时候都会采用RPC框架的方式.但是,它的TProtocol编解码框架还是可以以类库的方式独立使用的.
	与Protobuf比较类似的是,Thrift通过IDL描述接口和数据结构定义,它支持8中java基本类型,Map,Set和List,支持可选和必选定义,功能非常强大.因为可以定义数据结构中字段的顺序,所以它也可以支持协议的前向兼容.
		Thrift支持三种比较典型的编解码方式:
			1.通用的二进制编解码.
			2.压缩二进制编解码.
			3.优化的可选字段压缩编解码.
		由于支持二进制压缩编解码,Thrift的编解码性能表现也相当优异,远远超过java序列化和RMI等.
	3.JBoss Marshalling介绍:是一个java对象序列化API包,修正了jdk自带的序列化包的很多问题,但又保持跟java.io.Serializable接口的兼容.同事增加了一些可调的参数和附加的特性,并且这些参数和特性可通过工厂类进行配置.
	相比于传统的java序列化机制,优点:
		1.可插拔的类解析器,提供更加便捷的类加载定制策略,通过一个接口即可实现定制;
		2.可插拔的对象替换技术,不需要通过继承的方式;
		3.可插拔的预定义类缓存表,可以减少序列化的字节数组长度,提升常用类型的对象序列化性能.
		4.无需实现Serializable接口,即可实现java序列化;
		5.通过缓存技术提升对象序列化性能.
	相比于前两种编解码框架,JBoss Marshalling更多是在JBoss内部使用,应用范围有限.	
	CHP7MessagePack编解码:高效的二进制序列化框架,它像json一样支持不同语言间的数据交换,但是性能更快,序列化后的码流也更小.
		支持的语言:java,Python,Ruby,Haskell,c#,OCaml,Lua,Go,C,C++等.官网:http://msgpack.org/
		利用MessagePack做编解码工作,需要考虑半包处理问题.
		
		
		
		
		
			
			






	
	